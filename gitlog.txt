commit 7b5bb2222f9e4912ae8516fa1350b4258b179a5c
Author: Griffin Heyrich <gheyrich@csa1.bu.edu>
Date:   Wed Sep 16 16:31:28 2020 -0400

    added i++ to else statement in read_sequence

diff --git a/assignment-2.c b/assignment-2.c
index 7ff8c7e..94cf902 100644
--- a/assignment-2.c
+++ b/assignment-2.c
@@ -120,6 +120,7 @@ _Bool read_sequence(char s[], int seq_len) {
         i++;
       }
       else{
+        i++;
         continue;
       }
     }
diff --git a/gitlog.txt b/gitlog.txt
index 953bda0..c0fbaef 100644
--- a/gitlog.txt
+++ b/gitlog.txt
@@ -1,3 +1,723 @@
+commit 067b2df50f5796d0c2cccd345420cb4cf2c46aa3
+Author: Griffin Heyrich <gheyrich@csa1.bu.edu>
+Date:   Wed Sep 16 16:26:06 2020 -0400
+
+    trying to work out shifting the first array
+
+diff --git a/assignment-2.c b/assignment-2.c
+index c80a27f..7ff8c7e 100644
+--- a/assignment-2.c
++++ b/assignment-2.c
+@@ -115,7 +115,7 @@ _Bool read_sequence(char s[], int seq_len) {
+     // Loop until new line 
+     // FIXME: ADD your loop here
+     while(b != '\n' && i <= seq_len){
+-      if (b == 'A' || b == 'T' || b == 'C' || b == 'G'){
++      if (b == 'A' || b == 'T' || b == 'C' || b == 'G'){ // or is_valid_base == true;
+         s[i] == b;
+         i++;
+       }
+@@ -142,7 +142,9 @@ _Bool read_sequence(char s[], int seq_len) {
+  ****************************************************************************/
+ _Bool is_valid_base(char b) {
+   // FIXME: Add a loop here that compares the input b to elements of the bases array
+-
++    if (b == 'A' || b == 'T' || b == 'C' || b == 'G'){ //wait why do i need a loop???
++      return 1; 
++    }
+ 
+ 
+   // if we got here then we must not have matched any of the bases elements
+@@ -228,6 +230,23 @@ _Bool is_valid_base(char b) {
+  ****************************************************************************/
+ _Bool match(const char s1[], const char s2[],
+      int len1, int len2, int threshold) {
++    int overlap = 0;
++    int len = len1;
++    while(threshold > overlap){
++      if(s1[len - threshold + overlap] == s2[len2 - threshold + overlap]){
++        overlap++;
++      }
++      else{
++        len = len1-1;
++      }
++    }
++    if(overlap == threshold){
++      printf("A match was found.");
++      print_sequence(s1,len1);
++      return 1;
++    }
++      
++    
+    // FIXME:  This is where the real work has to happen 
+    //         implement this function using print_sequence_part as needed
+ 
+diff --git a/gitlog.txt b/gitlog.txt
+index e69de29..953bda0 100644
+--- a/gitlog.txt
++++ b/gitlog.txt
+@@ -0,0 +1,660 @@
++commit 62346a9fe90f8489686f126132f8dade2a0973f9
++Author: Griffin Heyrich <gheyrich@csa1.bu.edu>
++Date:   Wed Sep 16 14:48:55 2020 -0400
++
++    added loop to read_seqeunce
++
++diff --git a/assignment-2.c b/assignment-2.c
++index 9c0c60d..c80a27f 100644
++--- a/assignment-2.c
+++++ b/assignment-2.c
++@@ -114,6 +114,15 @@ _Bool read_sequence(char s[], int seq_len) {
++ 
++     // Loop until new line 
++     // FIXME: ADD your loop here
+++    while(b != '\n' && i <= seq_len){
+++      if (b == 'A' || b == 'T' || b == 'C' || b == 'G'){
+++        s[i] == b;
+++        i++;
+++      }
+++      else{
+++        continue;
+++      }
+++    }
++ 
++ 
++     // When we are done looping i should hold the length of valid bases read
++
++commit c1a8695268bc1979c8e7ac5e13e510f6de6125ea
++Author: Jonathan Appavoo <jappavoo@bu.edu>
++Date:   Mon Sep 14 18:15:36 2020 -0400
++
++    Initial Commit to seed assignment 2.  Second Fall 2020 CS210 Assignment.  Have fun!
++
++diff --git a/.gitignore b/.gitignore
++new file mode 100644
++index 0000000..e1a273a
++--- /dev/null
+++++ b/.gitignore
++@@ -0,0 +1,4 @@
+++*
+++!assignment-2.c
+++!gitlog.txt
+++
++diff --git a/.vscode/launch.json b/.vscode/launch.json
++new file mode 100644
++index 0000000..6eac52b
++--- /dev/null
+++++ b/.vscode/launch.json
++@@ -0,0 +1,30 @@
+++{
+++    // Use IntelliSense to learn about possible attributes.
+++    // Hover to view descriptions of existing attributes.
+++    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
+++    "version": "0.2.0",
+++    "configurations": [
+++    
+++
+++        {
+++            "name": "(gdb) Launch",
+++            "type": "cppdbg",
+++            "request": "launch",
+++            "program": "${workspaceFolder}/assignment-1",
+++            "args": [],
+++            "stopAtEntry": true,
+++            "cwd": "${workspaceFolder}",
+++            "environment": [],
+++            "externalConsole": false,
+++            "MIMode": "gdb",
+++            "setupCommands": [
+++                {
+++                    "description": "Enable pretty-printing for gdb",
+++                    "text": "-enable-pretty-printing",
+++                    "ignoreFailures": true
+++                }
+++            ],
+++            "preLaunchTask": "Build"
+++        }
+++    ]
+++}
++diff --git a/.vscode/settings.json b/.vscode/settings.json
++new file mode 100644
++index 0000000..2016988
++--- /dev/null
+++++ b/.vscode/settings.json
++@@ -0,0 +1,21 @@
+++{
+++    "git.ignoreLegacyWarning": true,
+++    "files.autoSave": "afterDelay",
+++    "files.exclude": {
+++        ".vscode": true,
+++        "**/*.o": true,
+++        "reference": true,
+++        "assignment-2": true,
+++        "test.sh":true,
+++        "gitlog.txt":true,
+++        ".gitignore":true
+++    },
+++    "editor.renderControlCharacters": true,
+++    "C_Cpp.default.cStandard": "c99",
+++    "C_Cpp.default.cppStandard": "gnu++11",
+++    "C_Cpp.default.defines": [],
+++    "C_Cpp.intelliSenseEngine": "Disabled",
+++    "C_Cpp.workspaceParsingPriority": "low",
+++    "C_Cpp.intelliSenseCacheSize": 100,
+++    "C_Cpp.default.browse.limitSymbolsToIncludedHeaders": true
+++}
++diff --git a/.vscode/tasks.json b/.vscode/tasks.json
++new file mode 100644
++index 0000000..d02618f
++--- /dev/null
+++++ b/.vscode/tasks.json
++@@ -0,0 +1,28 @@
+++{
+++    // See https://go.microsoft.com/fwlink/?LinkId=733558
+++    // for the documentation about the tasks.json format
+++    "version": "2.0.0",
+++    "tasks": [
+++        {
+++            "label": "Build",
+++            "type": "shell",
+++            "command": "make",
+++            "options": {
+++                "cwd": "${workspaceFolder}"
+++            },
+++            "group": {
+++                "kind": "build",
+++                "isDefault": true
+++            },
+++            "presentation": {
+++                "reveal": "always",
+++                "panel": "shared"
+++            },
+++            "problemMatcher": {
+++                "base": "$gcc",
+++                "fileLocation": ["relative", "${workspaceRoot}/"]
+++            }
+++        }
+++        
+++    ]
+++}
++diff --git a/Makefile b/Makefile
++new file mode 100644
++index 0000000..7a4370d
++--- /dev/null
+++++ b/Makefile
++@@ -0,0 +1,15 @@
+++.PHONY: all clean test gitlog
+++
+++all: assignment-2
+++
+++assignment-2: assignment-2.c
+++	${CC} -std=c99 -g assignment-2.c -o assignment-2
+++	
+++test: assignment-2 gitlog
+++	./test.sh
+++
+++gitlog:
+++	git log -p > gitlog.txt
+++	
+++clean:
+++	-${RM} assignment-2
++\ No newline at end of file
++diff --git a/assignment-2.c b/assignment-2.c
++new file mode 100644
++index 0000000..9c0c60d
++--- /dev/null
+++++ b/assignment-2.c
++@@ -0,0 +1,227 @@
+++/**
+++ * Assignment #2: Loops, functions, arrays.
+++ * This program computes simple DNA matching between 2 sequences.
+++ **/
+++
+++#include <stdio.h>
+++#include <stdbool.h>
+++
+++#define BASE_SEQ_LEN 20
+++#define TARGET_SEQ_LEN 5
+++#define NUM_BASES 4
+++#define THRESHOLD 3
+++
+++
+++/**********************************************************************
+++ *  You should :                                                      *
+++ *   1) carefully read over the writeup on piazza                     *
+++ *   2) carefully read over the code                                  *
+++ *   3) run make test to see how the reference binary behaves         *
+++ *   4) find the locations you need to add code and progressively     *
+++ *      update your code till it behaves the same as the reference.   *
+++ *      Don't forget to commit regularly as you conduct your work     *
+++ *                                                                    *
+++ *  Each function documents how it should behave.                     *
+++ *  If you are unsure about how your program should work use the      *
+++ *  the reference executable provided to understand what the correct  *
+++ *  behavior is.  When you run make test you see a series of          *
+++ *  inputs that we will be testing your program with.                 *
+++/**********************************************************************/
+++
+++/* function prototypes */
+++/*  See function definitions below for documentation */
+++_Bool read_sequence(char[], int);
+++_Bool match(const char[], const char[], int, int, int);
+++void print_sequence_part(const char[], int, int);
+++void print_sequence(const char[], int);
+++_Bool is_valid_base(char);
+++
+++/* external variables */
+++const char bases[] = {'A', 'T', 'C', 'G'};
+++
+++/**
+++ * main: This function needs to read and store a sequence of length
+++ *       BASE_SEQ_LEN. Then it needs to read and store a sequence of 
+++ *       TARGET_SEQ_LEN. Finally it needs to call match() with both sequences.
+++**/
+++int main() {
+++    char s1[20], s2[5];
+++
+++    // 1: Read base input sequence into s1 array
+++    if (read_sequence(s1, 20) == 0) {
+++      // if read_sequence returned false then there was an error
+++      printf("ERROR: sequence 1 is bad.  Exiting\n");
+++      return -1;
+++    }
+++    // FIXME: You need to finish the main function 
+++    // FIXME: 2: Read target input sequence into s2 array
+++
+++    // FIXME: 3: Call match function to look for match and print merged
+++    // sequence if a match is found
+++
+++
+++
+++
+++    return 0;
+++}
+++
+++/****************************************************************************
+++ * Prints a sequence part indicated by the start and end (excluded) indices.*
+++ ****************************************************************************/
+++void print_sequence_part(const char s[], int start, int end) {
+++    for (int i=start; i<end; i++) {
+++        printf("%c", s[i]);
+++    }
+++}
+++
+++/****************************************************************************
+++ * Prints a sequence of bases.                                              *
+++ ****************************************************************************/
+++void print_sequence(const char s[], int len) {
+++    print_sequence_part(s, 0, len);
+++    printf("\n");
+++}
+++
+++/****************************************************************************
+++ * Prompts the user to input a seq_len sequence and press Enter/Return      *
+++ * reads a sequence of bases (A, T, C, G) and stores it in s.               *
+++ * Invalid bases (values that not one of the four valid bases) are ignored. *
+++ * If the  sequence inputed is too short then return false                  *
+++ *                                                                          *
+++ * A newline '\n' is generated when the user presses the Enter or Return    *
+++ * key. In such cases scanf will read the special ascii value '\n' into the *
+++ * variable.                                                                *  
+++ *                                                                          *
+++ * In our case we should continue to read values until we encounter a       *
+++ * newline.  Prior to reading a newline each valid base should be stored    *
+++ * consecutively into the s array until seq_len valid values have been      *
+++ * read.  Any addtioinal values should be ignored.                          *
+++ * eg.                                                                      *
+++ *   assuming seq_len=3                                                     *
+++ *    INPUT: "AGG\n"->  s[0]='A' s[1]='G' s[2]='G' return true              *
+++ *    INPUT: "aAgGqGv\n"->  s[0]='A' s[1]='G' s[2]='G' return true          *
+++ *    INPUT: "A\n"-> s[0]='A' return false                                  *
+++ *    INPUT: "aaaaaaaaaaaaaa' -> return false                               *
+++ *    INPUT: "AGGTAGGT" -> s[0]='A' s[1]='G' s[2]='G' return true           *
+++ ****************************************************************************/
+++_Bool read_sequence(char s[], int seq_len) {
+++    char b;
+++    int i = 0;
+++
+++    printf("Enter a sequence of length %d: ", seq_len);
+++    // Read first character in to get us started
+++    scanf("%c", &b);
+++
+++    // Loop until new line 
+++    // FIXME: ADD your loop here
+++
+++
+++    // When we are done looping i should hold the length of valid bases read
+++    if (i != seq_len) {
+++      printf("Invalid: input sequence too short\n");
+++       return 0; // sequence too short
+++    }
+++    printf("Valid input sequence: ");
+++    print_sequence(s, seq_len);
+++    return 1;
+++}
+++
+++/****************************************************************************
+++ * Checks whether the input character represents a valid base.              *
+++ * Returns false if b is not in the bases array which is preloaded with     *
+++ *  'A', 'C', 'G', 'T'.                                                     *
+++ ****************************************************************************/
+++_Bool is_valid_base(char b) {
+++  // FIXME: Add a loop here that compares the input b to elements of the bases array
+++
+++
+++
+++  // if we got here then we must not have matched any of the bases elements
+++  return 0;
+++}
+++
+++/****************************************************************************
+++ *  This function will do the real work to try and match the two DNA        *
+++ *  sequences. In this case, the base sequence (variable s1) will be the    * 
+++ *  DNA sequence we are trying to reconstruct, and its length is stored in  *
+++ *  the variable len1. The target sequence (s2) will be the DNA sequence    * 
+++ *  that we are trying to match to the base sequence to determine if it is  *
+++ *  a part of that sequence, and its length is stored in len2.              *
+++ *                                                                          *
+++ *  This function needs to detect matches, and return whether or not a      *
+++ *  match was found. Additionally, this function needs to print out one of  *
+++ *  two possibilities, depending on if a match was found. If a match was    *
+++ *  found, the function needs to print out "A match was found" and then the *
+++ *  concatenated sequence. You can use the print_sequence_part function to  *
+++ *  help with printing out the concatenated sequence. If a match was not    *
+++ *  found, the function needs to print out "No match found".                *
+++ *                                                                          *
+++ *  There are two cases for matching that the function should check for.    *
+++ *  First is if the target sequence appears inside the base sequence        *
+++ *  itself.                                                                 *
+++ *  For example:                                                            *
+++ *                                                                          *
+++ *  Base: AAACTGGGT             =>  A match was found.                      *
+++ *  Target: ACTGG                   AAACTGGGT                               *
+++ *                                                                          *
+++ *  This would be a match because the target string ACTGG appears fully     *
+++ *  within the base seqeunce.                                               *
+++ *                                                                          *
+++ *  The other case is if the base sequence is a proper prefix to the target *
+++ *  string (the last bases of base sequence are the same as the first bases *
+++ *  of the target sequence) AND the length of the overlap is equal to or    *
+++ *  greater than the threshold. For example, assuming a threshold of 3:     *
+++ *                                                                          *
+++ *  Base: AAACTGGG              =>  A match was found.                      *
+++ *  Target:    GGGTC                AAACTGGGTC                              *
+++ *                                                                          *
+++ *  Base: AAACTGGG              =>  No match found.                         *
+++ *  Target:     GGACT                                                       *
+++ *                                                                          *
+++ *  The first example is a match because GGG is the last 3 bases of the     *
+++ *  base and the first 3 bases of the target. The second example is NOT a   *
+++ *  match because only 2 bases overlap.                                     *
+++ *                                                                          *
+++ *  One way to implement this is by lining up s2 at the end of s1 so that   *
+++ *  they have `threshold` bases overlap. If no valid match is found, slide  *
+++ *  s2 to left by one position. Repeat until either a match is found or no  *
+++ *  overlap >= threshold is possible anymore.                               *
+++ *                                                                          *
+++ *  Example:                                                                * 
+++ *  --------                                                                * 
+++ *  s1 = CCGTTACAGG, s2 = TACAG, threshold = 3                              * 
+++ *                                                                          * 
+++ *  CCGTTACAGG                                                              * 
+++ *         TACAG                                                            * 
+++ *                                                                          * 
+++ *  CCGTTACAGG                                                              * 
+++ *        TACAG                                                             * 
+++ *                                                                          * 
+++ *  CCGTTACAGG                                                              * 
+++ *       TACAG                                                              * 
+++ *                                                                          * 
+++ *  CCGTTACAGG                  =>  A match was found.                      *
+++ *      TACAG                       CCGTTACAGG                              *
+++ *                                                                          *
+++ *                                                                          *
+++ *  -----                                                                   *
+++ *  BONUS                                                                   *
+++ *  -----                                                                   *
+++ *  For bonus points, add functionality to detect matches where the target  *
+++ *  sequence is a proper prefix to the base sequence. For example:          *
+++ *                                                                          *
+++ *  Base:     AAACTGGG          =>  A match was found.                      *
+++ *  Target: GTAAA                   GTAAACTGGG                              *
+++ *                                                                          *
+++ *  This would be a match because because AAA is the last 3 bases of the    *
+++ *  target sequence and the first 3 bases of the base sequence.             *
+++ *                                                                          *
+++ ****************************************************************************/
+++_Bool match(const char s1[], const char s2[],
+++     int len1, int len2, int threshold) {
+++   // FIXME:  This is where the real work has to happen 
+++   //         implement this function using print_sequence_part as needed
+++
+++    printf("No match found.\n");
+++    return 0;
+++}
++diff --git a/gitlog.txt b/gitlog.txt
++new file mode 100644
++index 0000000..e69de29
++diff --git a/reference b/reference
++new file mode 100755
++index 0000000..1ff916b
++Binary files /dev/null and b/reference differ
++diff --git a/test.sh b/test.sh
++new file mode 100755
++index 0000000..cd2edd0
++--- /dev/null
+++++ b/test.sh
++@@ -0,0 +1,252 @@
+++#!/bin/bash
+++#set -x
+++
+++REFERENCE=./reference
+++PGM=./assignment-2
+++
+++# simple valid
+++BASE_SEQ1="AAAAAAAAAAAAAAAAAAAA"
+++TARGET_SEQ1="AAAAA"
+++
+++# VALID but has invalid characters that need to be ignored
+++BASE_SEQ2="aAAAaAAAaAAAaAAAaAAaAAaAaAaAaAaaaa"
+++TARGET_SEQ2="AAAAA"
+++
+++# BASE is invalid: too short
+++BASE_SEQ3="A"
+++TARGET_SEQ3="AAAAA"
+++
+++BASE_SEQ4="AAAAAAAAAAAAAAAAAAA"
+++TARGET_SEQ4="AAAAA"
+++
+++# base has invalid character
+++BASE_SEQ5="AAAAAAAAAAAAAAAAAAAB"
+++TARGET_SEQ5="AAAAA"
+++
+++# match, full overlap
+++BASE_SEQ6="GGGGGGGGAAAAAGGGGGGG"
+++TARGET_SEQ6="AAAAA"
+++
+++BASE_SEQ7="AAAAAGGGGGGGGGGGGGGG"
+++TARGET_SEQ7="AAAAA"
+++
+++BASE_SEQ8="GGGGGGGGGGGGGGGAAAAA"
+++TARGET_SEQ8="AAAAA"
+++
+++# no match
+++BASE_SEQ9="TTTTTTTTTTTTTTTTTTTT"
+++TARGET_SEQ9="AAAAA"
+++
+++BASE_SEQ10="ACGTACGTACGTACGTACGT"
+++TARGET_SEQ10="AAAAA"
+++
+++# target has invalid character, too short
+++BASE_SEQ11="ACGTACGTACGTACGTACGT"
+++TARGET_SEQ11="ACGTH"
+++
+++# match, either full overlap or target as suffix
+++BASE_SEQ12="ACGTACGTACGTACGTACGT"
+++TARGET_SEQ12="ACGTA"
+++
+++# match, target as suffix
+++BASE_SEQ13="ACGTACGTACGTACGTACGT"
+++TARGET_SEQ13="ACGTT"
+++
+++# match, target as suffix
+++BASE_SEQ14="ACGTTGCAACGTTGCAACGT"
+++TARGET_SEQ14="CGTAA"
+++
+++# no match
+++BASE_SEQ15="ACGTTGCAACGTTGCAACGT"
+++TARGET_SEQ15="GTCAA"
+++
+++# match, full overlap, extra characters ignored
+++BASE_SEQ16="ACGTACGTACGTACGTACGG"
+++TARGET_SEQ16="TACGGG"
+++
+++# target too short
+++BASE_SEQ17="AAAAAAAAAAAAAAAAAAAA"
+++TARGET_SEQ17="A"
+++
+++BASE_SEQ18="AAAAAAAAAAAAAAAAAAAA"
+++TARGET_SEQ18="AAAAB"
+++
+++BASE_SEQ19="AAAAAAAAAAAAAAAAAAAA"
+++TARGET_SEQ19="AaAaa"
+++
+++# empty base
+++BASE_SEQ20=""
+++TARGET_SEQ20="AAAAA"
+++
+++# empty target
+++BASE_SEQ21="AAAAAAAAAAAAAAAAAAAA"
+++TARGET_SEQ21=""
+++
+++## bonus
+++
+++# valid, target as prefix
+++BASE_BONUS1="ACGTTGCAACGTTGCAACGT"
+++TARGET_BONUS1="GGACG"
+++
+++# valid, target as prefix with ignored characters
+++BASE_BONUS2="AAGTACGTACGTACGTACGT"
+++TARGET_BONUS2="TAAAGT"
+++
+++# valid, target as prefix
+++BASE_BONUS3="ACGTACGTACGTACGTACGT"
+++TARGET_BONUS3="GACGT"
+++
+++# invalid, threshold larger than match
+++BASE_BONUS4="ACGTTGCAACGTTGCATTGG"
+++TARGET_BONUS4="TTTAC"
+++
+++# invalid, threshold larger than match after ignored characters
+++BASE_BONUS5="ACGTTGCAACGTTGCATTGG"
+++TARGET_BONUS5="TTTACG"
+++
+++function run_test()
+++{
+++   base=$1
+++   target=$2
+++   
+++   echo "Testing with BASE Sequence: $base and TARGET: $target"
+++   solution="$(echo -e "${base}\n${target}" | $REFERENCE)"
+++   answer="$(echo -e "${base}\n${target}" | $PGM)"
+++   if [[ "$answer" == "$solution" ]]; then
+++      echo "PASS"
+++      echo "$solution"
+++      return 0
+++   fi
+++   echo "FAIL: your program poduced: '$answer' output should have been: '$solution'"
+++   return 1
+++}
+++
+++total=0
+++correct=0
+++
+++if run_test $BASE_SEQ1 $TARGET_SEQ1; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ2 $TARGET_SEQ2; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ3 $TARGET_SEQ3; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ4 $TARGET_SEQ4; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ5 $TARGET_SEQ5; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ6 $TARGET_SEQ6; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ7 $TARGET_SEQ7; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ8 $TARGET_SEQ8; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ9 $TARGET_SEQ9; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ10 $TARGET_SEQ10; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ11 $TARGET_SE11; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ12 $TARGET_SEQ12; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ13 $TARGET_SEQ13; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ14 $TARGET_SEQ14; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ15 $TARGET_SEQ15; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ16 $TARGET_SEQ16; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ17 $TARGET_SEQ17; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ18 $TARGET_SEQ18; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ19 $TARGET_SEQ19; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ20 $TARGET_SEQ20; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_SEQ21 $TARGET_SEQ21; then
+++  ((correct++))
+++fi
+++((total++))
+++
+++if run_test $BASE_BONUS1 $TARGET_BONUS1; then
+++  ((correct++))
+++fi
+++
+++if run_test $BASE_BONUS2 $TARGET_BONUS2; then
+++  ((correct++))
+++fi
+++
+++if run_test $BASE_BONUS3 $TARGET_BONUS3; then
+++  ((correct++))
+++fi
+++
+++if run_test $BASE_BONUS4 $TARGET_BONUS4; then
+++  ((correct++))
+++fi
+++
+++if run_test $BASE_BONUS5 $TARGET_BONUS5; then
+++  ((correct++))
+++fi
+++
+++echo "score: ${correct}/${total}"
+
 commit 62346a9fe90f8489686f126132f8dade2a0973f9
 Author: Griffin Heyrich <gheyrich@csa1.bu.edu>
 Date:   Wed Sep 16 14:48:55 2020 -0400

commit 067b2df50f5796d0c2cccd345420cb4cf2c46aa3
Author: Griffin Heyrich <gheyrich@csa1.bu.edu>
Date:   Wed Sep 16 16:26:06 2020 -0400

    trying to work out shifting the first array

diff --git a/assignment-2.c b/assignment-2.c
index c80a27f..7ff8c7e 100644
--- a/assignment-2.c
+++ b/assignment-2.c
@@ -115,7 +115,7 @@ _Bool read_sequence(char s[], int seq_len) {
     // Loop until new line 
     // FIXME: ADD your loop here
     while(b != '\n' && i <= seq_len){
-      if (b == 'A' || b == 'T' || b == 'C' || b == 'G'){
+      if (b == 'A' || b == 'T' || b == 'C' || b == 'G'){ // or is_valid_base == true;
         s[i] == b;
         i++;
       }
@@ -142,7 +142,9 @@ _Bool read_sequence(char s[], int seq_len) {
  ****************************************************************************/
 _Bool is_valid_base(char b) {
   // FIXME: Add a loop here that compares the input b to elements of the bases array
-
+    if (b == 'A' || b == 'T' || b == 'C' || b == 'G'){ //wait why do i need a loop???
+      return 1; 
+    }
 
 
   // if we got here then we must not have matched any of the bases elements
@@ -228,6 +230,23 @@ _Bool is_valid_base(char b) {
  ****************************************************************************/
 _Bool match(const char s1[], const char s2[],
      int len1, int len2, int threshold) {
+    int overlap = 0;
+    int len = len1;
+    while(threshold > overlap){
+      if(s1[len - threshold + overlap] == s2[len2 - threshold + overlap]){
+        overlap++;
+      }
+      else{
+        len = len1-1;
+      }
+    }
+    if(overlap == threshold){
+      printf("A match was found.");
+      print_sequence(s1,len1);
+      return 1;
+    }
+      
+    
    // FIXME:  This is where the real work has to happen 
    //         implement this function using print_sequence_part as needed
 
diff --git a/gitlog.txt b/gitlog.txt
index e69de29..953bda0 100644
--- a/gitlog.txt
+++ b/gitlog.txt
@@ -0,0 +1,660 @@
+commit 62346a9fe90f8489686f126132f8dade2a0973f9
+Author: Griffin Heyrich <gheyrich@csa1.bu.edu>
+Date:   Wed Sep 16 14:48:55 2020 -0400
+
+    added loop to read_seqeunce
+
+diff --git a/assignment-2.c b/assignment-2.c
+index 9c0c60d..c80a27f 100644
+--- a/assignment-2.c
++++ b/assignment-2.c
+@@ -114,6 +114,15 @@ _Bool read_sequence(char s[], int seq_len) {
+ 
+     // Loop until new line 
+     // FIXME: ADD your loop here
++    while(b != '\n' && i <= seq_len){
++      if (b == 'A' || b == 'T' || b == 'C' || b == 'G'){
++        s[i] == b;
++        i++;
++      }
++      else{
++        continue;
++      }
++    }
+ 
+ 
+     // When we are done looping i should hold the length of valid bases read
+
+commit c1a8695268bc1979c8e7ac5e13e510f6de6125ea
+Author: Jonathan Appavoo <jappavoo@bu.edu>
+Date:   Mon Sep 14 18:15:36 2020 -0400
+
+    Initial Commit to seed assignment 2.  Second Fall 2020 CS210 Assignment.  Have fun!
+
+diff --git a/.gitignore b/.gitignore
+new file mode 100644
+index 0000000..e1a273a
+--- /dev/null
++++ b/.gitignore
+@@ -0,0 +1,4 @@
++*
++!assignment-2.c
++!gitlog.txt
++
+diff --git a/.vscode/launch.json b/.vscode/launch.json
+new file mode 100644
+index 0000000..6eac52b
+--- /dev/null
++++ b/.vscode/launch.json
+@@ -0,0 +1,30 @@
++{
++    // Use IntelliSense to learn about possible attributes.
++    // Hover to view descriptions of existing attributes.
++    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
++    "version": "0.2.0",
++    "configurations": [
++    
++
++        {
++            "name": "(gdb) Launch",
++            "type": "cppdbg",
++            "request": "launch",
++            "program": "${workspaceFolder}/assignment-1",
++            "args": [],
++            "stopAtEntry": true,
++            "cwd": "${workspaceFolder}",
++            "environment": [],
++            "externalConsole": false,
++            "MIMode": "gdb",
++            "setupCommands": [
++                {
++                    "description": "Enable pretty-printing for gdb",
++                    "text": "-enable-pretty-printing",
++                    "ignoreFailures": true
++                }
++            ],
++            "preLaunchTask": "Build"
++        }
++    ]
++}
+diff --git a/.vscode/settings.json b/.vscode/settings.json
+new file mode 100644
+index 0000000..2016988
+--- /dev/null
++++ b/.vscode/settings.json
+@@ -0,0 +1,21 @@
++{
++    "git.ignoreLegacyWarning": true,
++    "files.autoSave": "afterDelay",
++    "files.exclude": {
++        ".vscode": true,
++        "**/*.o": true,
++        "reference": true,
++        "assignment-2": true,
++        "test.sh":true,
++        "gitlog.txt":true,
++        ".gitignore":true
++    },
++    "editor.renderControlCharacters": true,
++    "C_Cpp.default.cStandard": "c99",
++    "C_Cpp.default.cppStandard": "gnu++11",
++    "C_Cpp.default.defines": [],
++    "C_Cpp.intelliSenseEngine": "Disabled",
++    "C_Cpp.workspaceParsingPriority": "low",
++    "C_Cpp.intelliSenseCacheSize": 100,
++    "C_Cpp.default.browse.limitSymbolsToIncludedHeaders": true
++}
+diff --git a/.vscode/tasks.json b/.vscode/tasks.json
+new file mode 100644
+index 0000000..d02618f
+--- /dev/null
++++ b/.vscode/tasks.json
+@@ -0,0 +1,28 @@
++{
++    // See https://go.microsoft.com/fwlink/?LinkId=733558
++    // for the documentation about the tasks.json format
++    "version": "2.0.0",
++    "tasks": [
++        {
++            "label": "Build",
++            "type": "shell",
++            "command": "make",
++            "options": {
++                "cwd": "${workspaceFolder}"
++            },
++            "group": {
++                "kind": "build",
++                "isDefault": true
++            },
++            "presentation": {
++                "reveal": "always",
++                "panel": "shared"
++            },
++            "problemMatcher": {
++                "base": "$gcc",
++                "fileLocation": ["relative", "${workspaceRoot}/"]
++            }
++        }
++        
++    ]
++}
+diff --git a/Makefile b/Makefile
+new file mode 100644
+index 0000000..7a4370d
+--- /dev/null
++++ b/Makefile
+@@ -0,0 +1,15 @@
++.PHONY: all clean test gitlog
++
++all: assignment-2
++
++assignment-2: assignment-2.c
++	${CC} -std=c99 -g assignment-2.c -o assignment-2
++	
++test: assignment-2 gitlog
++	./test.sh
++
++gitlog:
++	git log -p > gitlog.txt
++	
++clean:
++	-${RM} assignment-2
+\ No newline at end of file
+diff --git a/assignment-2.c b/assignment-2.c
+new file mode 100644
+index 0000000..9c0c60d
+--- /dev/null
++++ b/assignment-2.c
+@@ -0,0 +1,227 @@
++/**
++ * Assignment #2: Loops, functions, arrays.
++ * This program computes simple DNA matching between 2 sequences.
++ **/
++
++#include <stdio.h>
++#include <stdbool.h>
++
++#define BASE_SEQ_LEN 20
++#define TARGET_SEQ_LEN 5
++#define NUM_BASES 4
++#define THRESHOLD 3
++
++
++/**********************************************************************
++ *  You should :                                                      *
++ *   1) carefully read over the writeup on piazza                     *
++ *   2) carefully read over the code                                  *
++ *   3) run make test to see how the reference binary behaves         *
++ *   4) find the locations you need to add code and progressively     *
++ *      update your code till it behaves the same as the reference.   *
++ *      Don't forget to commit regularly as you conduct your work     *
++ *                                                                    *
++ *  Each function documents how it should behave.                     *
++ *  If you are unsure about how your program should work use the      *
++ *  the reference executable provided to understand what the correct  *
++ *  behavior is.  When you run make test you see a series of          *
++ *  inputs that we will be testing your program with.                 *
++/**********************************************************************/
++
++/* function prototypes */
++/*  See function definitions below for documentation */
++_Bool read_sequence(char[], int);
++_Bool match(const char[], const char[], int, int, int);
++void print_sequence_part(const char[], int, int);
++void print_sequence(const char[], int);
++_Bool is_valid_base(char);
++
++/* external variables */
++const char bases[] = {'A', 'T', 'C', 'G'};
++
++/**
++ * main: This function needs to read and store a sequence of length
++ *       BASE_SEQ_LEN. Then it needs to read and store a sequence of 
++ *       TARGET_SEQ_LEN. Finally it needs to call match() with both sequences.
++**/
++int main() {
++    char s1[20], s2[5];
++
++    // 1: Read base input sequence into s1 array
++    if (read_sequence(s1, 20) == 0) {
++      // if read_sequence returned false then there was an error
++      printf("ERROR: sequence 1 is bad.  Exiting\n");
++      return -1;
++    }
++    // FIXME: You need to finish the main function 
++    // FIXME: 2: Read target input sequence into s2 array
++
++    // FIXME: 3: Call match function to look for match and print merged
++    // sequence if a match is found
++
++
++
++
++    return 0;
++}
++
++/****************************************************************************
++ * Prints a sequence part indicated by the start and end (excluded) indices.*
++ ****************************************************************************/
++void print_sequence_part(const char s[], int start, int end) {
++    for (int i=start; i<end; i++) {
++        printf("%c", s[i]);
++    }
++}
++
++/****************************************************************************
++ * Prints a sequence of bases.                                              *
++ ****************************************************************************/
++void print_sequence(const char s[], int len) {
++    print_sequence_part(s, 0, len);
++    printf("\n");
++}
++
++/****************************************************************************
++ * Prompts the user to input a seq_len sequence and press Enter/Return      *
++ * reads a sequence of bases (A, T, C, G) and stores it in s.               *
++ * Invalid bases (values that not one of the four valid bases) are ignored. *
++ * If the  sequence inputed is too short then return false                  *
++ *                                                                          *
++ * A newline '\n' is generated when the user presses the Enter or Return    *
++ * key. In such cases scanf will read the special ascii value '\n' into the *
++ * variable.                                                                *  
++ *                                                                          *
++ * In our case we should continue to read values until we encounter a       *
++ * newline.  Prior to reading a newline each valid base should be stored    *
++ * consecutively into the s array until seq_len valid values have been      *
++ * read.  Any addtioinal values should be ignored.                          *
++ * eg.                                                                      *
++ *   assuming seq_len=3                                                     *
++ *    INPUT: "AGG\n"->  s[0]='A' s[1]='G' s[2]='G' return true              *
++ *    INPUT: "aAgGqGv\n"->  s[0]='A' s[1]='G' s[2]='G' return true          *
++ *    INPUT: "A\n"-> s[0]='A' return false                                  *
++ *    INPUT: "aaaaaaaaaaaaaa' -> return false                               *
++ *    INPUT: "AGGTAGGT" -> s[0]='A' s[1]='G' s[2]='G' return true           *
++ ****************************************************************************/
++_Bool read_sequence(char s[], int seq_len) {
++    char b;
++    int i = 0;
++
++    printf("Enter a sequence of length %d: ", seq_len);
++    // Read first character in to get us started
++    scanf("%c", &b);
++
++    // Loop until new line 
++    // FIXME: ADD your loop here
++
++
++    // When we are done looping i should hold the length of valid bases read
++    if (i != seq_len) {
++      printf("Invalid: input sequence too short\n");
++       return 0; // sequence too short
++    }
++    printf("Valid input sequence: ");
++    print_sequence(s, seq_len);
++    return 1;
++}
++
++/****************************************************************************
++ * Checks whether the input character represents a valid base.              *
++ * Returns false if b is not in the bases array which is preloaded with     *
++ *  'A', 'C', 'G', 'T'.                                                     *
++ ****************************************************************************/
++_Bool is_valid_base(char b) {
++  // FIXME: Add a loop here that compares the input b to elements of the bases array
++
++
++
++  // if we got here then we must not have matched any of the bases elements
++  return 0;
++}
++
++/****************************************************************************
++ *  This function will do the real work to try and match the two DNA        *
++ *  sequences. In this case, the base sequence (variable s1) will be the    * 
++ *  DNA sequence we are trying to reconstruct, and its length is stored in  *
++ *  the variable len1. The target sequence (s2) will be the DNA sequence    * 
++ *  that we are trying to match to the base sequence to determine if it is  *
++ *  a part of that sequence, and its length is stored in len2.              *
++ *                                                                          *
++ *  This function needs to detect matches, and return whether or not a      *
++ *  match was found. Additionally, this function needs to print out one of  *
++ *  two possibilities, depending on if a match was found. If a match was    *
++ *  found, the function needs to print out "A match was found" and then the *
++ *  concatenated sequence. You can use the print_sequence_part function to  *
++ *  help with printing out the concatenated sequence. If a match was not    *
++ *  found, the function needs to print out "No match found".                *
++ *                                                                          *
++ *  There are two cases for matching that the function should check for.    *
++ *  First is if the target sequence appears inside the base sequence        *
++ *  itself.                                                                 *
++ *  For example:                                                            *
++ *                                                                          *
++ *  Base: AAACTGGGT             =>  A match was found.                      *
++ *  Target: ACTGG                   AAACTGGGT                               *
++ *                                                                          *
++ *  This would be a match because the target string ACTGG appears fully     *
++ *  within the base seqeunce.                                               *
++ *                                                                          *
++ *  The other case is if the base sequence is a proper prefix to the target *
++ *  string (the last bases of base sequence are the same as the first bases *
++ *  of the target sequence) AND the length of the overlap is equal to or    *
++ *  greater than the threshold. For example, assuming a threshold of 3:     *
++ *                                                                          *
++ *  Base: AAACTGGG              =>  A match was found.                      *
++ *  Target:    GGGTC                AAACTGGGTC                              *
++ *                                                                          *
++ *  Base: AAACTGGG              =>  No match found.                         *
++ *  Target:     GGACT                                                       *
++ *                                                                          *
++ *  The first example is a match because GGG is the last 3 bases of the     *
++ *  base and the first 3 bases of the target. The second example is NOT a   *
++ *  match because only 2 bases overlap.                                     *
++ *                                                                          *
++ *  One way to implement this is by lining up s2 at the end of s1 so that   *
++ *  they have `threshold` bases overlap. If no valid match is found, slide  *
++ *  s2 to left by one position. Repeat until either a match is found or no  *
++ *  overlap >= threshold is possible anymore.                               *
++ *                                                                          *
++ *  Example:                                                                * 
++ *  --------                                                                * 
++ *  s1 = CCGTTACAGG, s2 = TACAG, threshold = 3                              * 
++ *                                                                          * 
++ *  CCGTTACAGG                                                              * 
++ *         TACAG                                                            * 
++ *                                                                          * 
++ *  CCGTTACAGG                                                              * 
++ *        TACAG                                                             * 
++ *                                                                          * 
++ *  CCGTTACAGG                                                              * 
++ *       TACAG                                                              * 
++ *                                                                          * 
++ *  CCGTTACAGG                  =>  A match was found.                      *
++ *      TACAG                       CCGTTACAGG                              *
++ *                                                                          *
++ *                                                                          *
++ *  -----                                                                   *
++ *  BONUS                                                                   *
++ *  -----                                                                   *
++ *  For bonus points, add functionality to detect matches where the target  *
++ *  sequence is a proper prefix to the base sequence. For example:          *
++ *                                                                          *
++ *  Base:     AAACTGGG          =>  A match was found.                      *
++ *  Target: GTAAA                   GTAAACTGGG                              *
++ *                                                                          *
++ *  This would be a match because because AAA is the last 3 bases of the    *
++ *  target sequence and the first 3 bases of the base sequence.             *
++ *                                                                          *
++ ****************************************************************************/
++_Bool match(const char s1[], const char s2[],
++     int len1, int len2, int threshold) {
++   // FIXME:  This is where the real work has to happen 
++   //         implement this function using print_sequence_part as needed
++
++    printf("No match found.\n");
++    return 0;
++}
+diff --git a/gitlog.txt b/gitlog.txt
+new file mode 100644
+index 0000000..e69de29
+diff --git a/reference b/reference
+new file mode 100755
+index 0000000..1ff916b
+Binary files /dev/null and b/reference differ
+diff --git a/test.sh b/test.sh
+new file mode 100755
+index 0000000..cd2edd0
+--- /dev/null
++++ b/test.sh
+@@ -0,0 +1,252 @@
++#!/bin/bash
++#set -x
++
++REFERENCE=./reference
++PGM=./assignment-2
++
++# simple valid
++BASE_SEQ1="AAAAAAAAAAAAAAAAAAAA"
++TARGET_SEQ1="AAAAA"
++
++# VALID but has invalid characters that need to be ignored
++BASE_SEQ2="aAAAaAAAaAAAaAAAaAAaAAaAaAaAaAaaaa"
++TARGET_SEQ2="AAAAA"
++
++# BASE is invalid: too short
++BASE_SEQ3="A"
++TARGET_SEQ3="AAAAA"
++
++BASE_SEQ4="AAAAAAAAAAAAAAAAAAA"
++TARGET_SEQ4="AAAAA"
++
++# base has invalid character
++BASE_SEQ5="AAAAAAAAAAAAAAAAAAAB"
++TARGET_SEQ5="AAAAA"
++
++# match, full overlap
++BASE_SEQ6="GGGGGGGGAAAAAGGGGGGG"
++TARGET_SEQ6="AAAAA"
++
++BASE_SEQ7="AAAAAGGGGGGGGGGGGGGG"
++TARGET_SEQ7="AAAAA"
++
++BASE_SEQ8="GGGGGGGGGGGGGGGAAAAA"
++TARGET_SEQ8="AAAAA"
++
++# no match
++BASE_SEQ9="TTTTTTTTTTTTTTTTTTTT"
++TARGET_SEQ9="AAAAA"
++
++BASE_SEQ10="ACGTACGTACGTACGTACGT"
++TARGET_SEQ10="AAAAA"
++
++# target has invalid character, too short
++BASE_SEQ11="ACGTACGTACGTACGTACGT"
++TARGET_SEQ11="ACGTH"
++
++# match, either full overlap or target as suffix
++BASE_SEQ12="ACGTACGTACGTACGTACGT"
++TARGET_SEQ12="ACGTA"
++
++# match, target as suffix
++BASE_SEQ13="ACGTACGTACGTACGTACGT"
++TARGET_SEQ13="ACGTT"
++
++# match, target as suffix
++BASE_SEQ14="ACGTTGCAACGTTGCAACGT"
++TARGET_SEQ14="CGTAA"
++
++# no match
++BASE_SEQ15="ACGTTGCAACGTTGCAACGT"
++TARGET_SEQ15="GTCAA"
++
++# match, full overlap, extra characters ignored
++BASE_SEQ16="ACGTACGTACGTACGTACGG"
++TARGET_SEQ16="TACGGG"
++
++# target too short
++BASE_SEQ17="AAAAAAAAAAAAAAAAAAAA"
++TARGET_SEQ17="A"
++
++BASE_SEQ18="AAAAAAAAAAAAAAAAAAAA"
++TARGET_SEQ18="AAAAB"
++
++BASE_SEQ19="AAAAAAAAAAAAAAAAAAAA"
++TARGET_SEQ19="AaAaa"
++
++# empty base
++BASE_SEQ20=""
++TARGET_SEQ20="AAAAA"
++
++# empty target
++BASE_SEQ21="AAAAAAAAAAAAAAAAAAAA"
++TARGET_SEQ21=""
++
++## bonus
++
++# valid, target as prefix
++BASE_BONUS1="ACGTTGCAACGTTGCAACGT"
++TARGET_BONUS1="GGACG"
++
++# valid, target as prefix with ignored characters
++BASE_BONUS2="AAGTACGTACGTACGTACGT"
++TARGET_BONUS2="TAAAGT"
++
++# valid, target as prefix
++BASE_BONUS3="ACGTACGTACGTACGTACGT"
++TARGET_BONUS3="GACGT"
++
++# invalid, threshold larger than match
++BASE_BONUS4="ACGTTGCAACGTTGCATTGG"
++TARGET_BONUS4="TTTAC"
++
++# invalid, threshold larger than match after ignored characters
++BASE_BONUS5="ACGTTGCAACGTTGCATTGG"
++TARGET_BONUS5="TTTACG"
++
++function run_test()
++{
++   base=$1
++   target=$2
++   
++   echo "Testing with BASE Sequence: $base and TARGET: $target"
++   solution="$(echo -e "${base}\n${target}" | $REFERENCE)"
++   answer="$(echo -e "${base}\n${target}" | $PGM)"
++   if [[ "$answer" == "$solution" ]]; then
++      echo "PASS"
++      echo "$solution"
++      return 0
++   fi
++   echo "FAIL: your program poduced: '$answer' output should have been: '$solution'"
++   return 1
++}
++
++total=0
++correct=0
++
++if run_test $BASE_SEQ1 $TARGET_SEQ1; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ2 $TARGET_SEQ2; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ3 $TARGET_SEQ3; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ4 $TARGET_SEQ4; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ5 $TARGET_SEQ5; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ6 $TARGET_SEQ6; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ7 $TARGET_SEQ7; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ8 $TARGET_SEQ8; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ9 $TARGET_SEQ9; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ10 $TARGET_SEQ10; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ11 $TARGET_SE11; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ12 $TARGET_SEQ12; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ13 $TARGET_SEQ13; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ14 $TARGET_SEQ14; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ15 $TARGET_SEQ15; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ16 $TARGET_SEQ16; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ17 $TARGET_SEQ17; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ18 $TARGET_SEQ18; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ19 $TARGET_SEQ19; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ20 $TARGET_SEQ20; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_SEQ21 $TARGET_SEQ21; then
++  ((correct++))
++fi
++((total++))
++
++if run_test $BASE_BONUS1 $TARGET_BONUS1; then
++  ((correct++))
++fi
++
++if run_test $BASE_BONUS2 $TARGET_BONUS2; then
++  ((correct++))
++fi
++
++if run_test $BASE_BONUS3 $TARGET_BONUS3; then
++  ((correct++))
++fi
++
++if run_test $BASE_BONUS4 $TARGET_BONUS4; then
++  ((correct++))
++fi
++
++if run_test $BASE_BONUS5 $TARGET_BONUS5; then
++  ((correct++))
++fi
++
++echo "score: ${correct}/${total}"

commit 62346a9fe90f8489686f126132f8dade2a0973f9
Author: Griffin Heyrich <gheyrich@csa1.bu.edu>
Date:   Wed Sep 16 14:48:55 2020 -0400

    added loop to read_seqeunce

diff --git a/assignment-2.c b/assignment-2.c
index 9c0c60d..c80a27f 100644
--- a/assignment-2.c
+++ b/assignment-2.c
@@ -114,6 +114,15 @@ _Bool read_sequence(char s[], int seq_len) {
 
     // Loop until new line 
     // FIXME: ADD your loop here
+    while(b != '\n' && i <= seq_len){
+      if (b == 'A' || b == 'T' || b == 'C' || b == 'G'){
+        s[i] == b;
+        i++;
+      }
+      else{
+        continue;
+      }
+    }
 
 
     // When we are done looping i should hold the length of valid bases read

commit c1a8695268bc1979c8e7ac5e13e510f6de6125ea
Author: Jonathan Appavoo <jappavoo@bu.edu>
Date:   Mon Sep 14 18:15:36 2020 -0400

    Initial Commit to seed assignment 2.  Second Fall 2020 CS210 Assignment.  Have fun!

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..e1a273a
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,4 @@
+*
+!assignment-2.c
+!gitlog.txt
+
diff --git a/.vscode/launch.json b/.vscode/launch.json
new file mode 100644
index 0000000..6eac52b
--- /dev/null
+++ b/.vscode/launch.json
@@ -0,0 +1,30 @@
+{
+    // Use IntelliSense to learn about possible attributes.
+    // Hover to view descriptions of existing attributes.
+    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
+    "version": "0.2.0",
+    "configurations": [
+    
+
+        {
+            "name": "(gdb) Launch",
+            "type": "cppdbg",
+            "request": "launch",
+            "program": "${workspaceFolder}/assignment-1",
+            "args": [],
+            "stopAtEntry": true,
+            "cwd": "${workspaceFolder}",
+            "environment": [],
+            "externalConsole": false,
+            "MIMode": "gdb",
+            "setupCommands": [
+                {
+                    "description": "Enable pretty-printing for gdb",
+                    "text": "-enable-pretty-printing",
+                    "ignoreFailures": true
+                }
+            ],
+            "preLaunchTask": "Build"
+        }
+    ]
+}
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..2016988
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,21 @@
+{
+    "git.ignoreLegacyWarning": true,
+    "files.autoSave": "afterDelay",
+    "files.exclude": {
+        ".vscode": true,
+        "**/*.o": true,
+        "reference": true,
+        "assignment-2": true,
+        "test.sh":true,
+        "gitlog.txt":true,
+        ".gitignore":true
+    },
+    "editor.renderControlCharacters": true,
+    "C_Cpp.default.cStandard": "c99",
+    "C_Cpp.default.cppStandard": "gnu++11",
+    "C_Cpp.default.defines": [],
+    "C_Cpp.intelliSenseEngine": "Disabled",
+    "C_Cpp.workspaceParsingPriority": "low",
+    "C_Cpp.intelliSenseCacheSize": 100,
+    "C_Cpp.default.browse.limitSymbolsToIncludedHeaders": true
+}
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 0000000..d02618f
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,28 @@
+{
+    // See https://go.microsoft.com/fwlink/?LinkId=733558
+    // for the documentation about the tasks.json format
+    "version": "2.0.0",
+    "tasks": [
+        {
+            "label": "Build",
+            "type": "shell",
+            "command": "make",
+            "options": {
+                "cwd": "${workspaceFolder}"
+            },
+            "group": {
+                "kind": "build",
+                "isDefault": true
+            },
+            "presentation": {
+                "reveal": "always",
+                "panel": "shared"
+            },
+            "problemMatcher": {
+                "base": "$gcc",
+                "fileLocation": ["relative", "${workspaceRoot}/"]
+            }
+        }
+        
+    ]
+}
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..7a4370d
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,15 @@
+.PHONY: all clean test gitlog
+
+all: assignment-2
+
+assignment-2: assignment-2.c
+	${CC} -std=c99 -g assignment-2.c -o assignment-2
+	
+test: assignment-2 gitlog
+	./test.sh
+
+gitlog:
+	git log -p > gitlog.txt
+	
+clean:
+	-${RM} assignment-2
\ No newline at end of file
diff --git a/assignment-2.c b/assignment-2.c
new file mode 100644
index 0000000..9c0c60d
--- /dev/null
+++ b/assignment-2.c
@@ -0,0 +1,227 @@
+/**
+ * Assignment #2: Loops, functions, arrays.
+ * This program computes simple DNA matching between 2 sequences.
+ **/
+
+#include <stdio.h>
+#include <stdbool.h>
+
+#define BASE_SEQ_LEN 20
+#define TARGET_SEQ_LEN 5
+#define NUM_BASES 4
+#define THRESHOLD 3
+
+
+/**********************************************************************
+ *  You should :                                                      *
+ *   1) carefully read over the writeup on piazza                     *
+ *   2) carefully read over the code                                  *
+ *   3) run make test to see how the reference binary behaves         *
+ *   4) find the locations you need to add code and progressively     *
+ *      update your code till it behaves the same as the reference.   *
+ *      Don't forget to commit regularly as you conduct your work     *
+ *                                                                    *
+ *  Each function documents how it should behave.                     *
+ *  If you are unsure about how your program should work use the      *
+ *  the reference executable provided to understand what the correct  *
+ *  behavior is.  When you run make test you see a series of          *
+ *  inputs that we will be testing your program with.                 *
+/**********************************************************************/
+
+/* function prototypes */
+/*  See function definitions below for documentation */
+_Bool read_sequence(char[], int);
+_Bool match(const char[], const char[], int, int, int);
+void print_sequence_part(const char[], int, int);
+void print_sequence(const char[], int);
+_Bool is_valid_base(char);
+
+/* external variables */
+const char bases[] = {'A', 'T', 'C', 'G'};
+
+/**
+ * main: This function needs to read and store a sequence of length
+ *       BASE_SEQ_LEN. Then it needs to read and store a sequence of 
+ *       TARGET_SEQ_LEN. Finally it needs to call match() with both sequences.
+**/
+int main() {
+    char s1[20], s2[5];
+
+    // 1: Read base input sequence into s1 array
+    if (read_sequence(s1, 20) == 0) {
+      // if read_sequence returned false then there was an error
+      printf("ERROR: sequence 1 is bad.  Exiting\n");
+      return -1;
+    }
+    // FIXME: You need to finish the main function 
+    // FIXME: 2: Read target input sequence into s2 array
+
+    // FIXME: 3: Call match function to look for match and print merged
+    // sequence if a match is found
+
+
+
+
+    return 0;
+}
+
+/****************************************************************************
+ * Prints a sequence part indicated by the start and end (excluded) indices.*
+ ****************************************************************************/
+void print_sequence_part(const char s[], int start, int end) {
+    for (int i=start; i<end; i++) {
+        printf("%c", s[i]);
+    }
+}
+
+/****************************************************************************
+ * Prints a sequence of bases.                                              *
+ ****************************************************************************/
+void print_sequence(const char s[], int len) {
+    print_sequence_part(s, 0, len);
+    printf("\n");
+}
+
+/****************************************************************************
+ * Prompts the user to input a seq_len sequence and press Enter/Return      *
+ * reads a sequence of bases (A, T, C, G) and stores it in s.               *
+ * Invalid bases (values that not one of the four valid bases) are ignored. *
+ * If the  sequence inputed is too short then return false                  *
+ *                                                                          *
+ * A newline '\n' is generated when the user presses the Enter or Return    *
+ * key. In such cases scanf will read the special ascii value '\n' into the *
+ * variable.                                                                *  
+ *                                                                          *
+ * In our case we should continue to read values until we encounter a       *
+ * newline.  Prior to reading a newline each valid base should be stored    *
+ * consecutively into the s array until seq_len valid values have been      *
+ * read.  Any addtioinal values should be ignored.                          *
+ * eg.                                                                      *
+ *   assuming seq_len=3                                                     *
+ *    INPUT: "AGG\n"->  s[0]='A' s[1]='G' s[2]='G' return true              *
+ *    INPUT: "aAgGqGv\n"->  s[0]='A' s[1]='G' s[2]='G' return true          *
+ *    INPUT: "A\n"-> s[0]='A' return false                                  *
+ *    INPUT: "aaaaaaaaaaaaaa' -> return false                               *
+ *    INPUT: "AGGTAGGT" -> s[0]='A' s[1]='G' s[2]='G' return true           *
+ ****************************************************************************/
+_Bool read_sequence(char s[], int seq_len) {
+    char b;
+    int i = 0;
+
+    printf("Enter a sequence of length %d: ", seq_len);
+    // Read first character in to get us started
+    scanf("%c", &b);
+
+    // Loop until new line 
+    // FIXME: ADD your loop here
+
+
+    // When we are done looping i should hold the length of valid bases read
+    if (i != seq_len) {
+      printf("Invalid: input sequence too short\n");
+       return 0; // sequence too short
+    }
+    printf("Valid input sequence: ");
+    print_sequence(s, seq_len);
+    return 1;
+}
+
+/****************************************************************************
+ * Checks whether the input character represents a valid base.              *
+ * Returns false if b is not in the bases array which is preloaded with     *
+ *  'A', 'C', 'G', 'T'.                                                     *
+ ****************************************************************************/
+_Bool is_valid_base(char b) {
+  // FIXME: Add a loop here that compares the input b to elements of the bases array
+
+
+
+  // if we got here then we must not have matched any of the bases elements
+  return 0;
+}
+
+/****************************************************************************
+ *  This function will do the real work to try and match the two DNA        *
+ *  sequences. In this case, the base sequence (variable s1) will be the    * 
+ *  DNA sequence we are trying to reconstruct, and its length is stored in  *
+ *  the variable len1. The target sequence (s2) will be the DNA sequence    * 
+ *  that we are trying to match to the base sequence to determine if it is  *
+ *  a part of that sequence, and its length is stored in len2.              *
+ *                                                                          *
+ *  This function needs to detect matches, and return whether or not a      *
+ *  match was found. Additionally, this function needs to print out one of  *
+ *  two possibilities, depending on if a match was found. If a match was    *
+ *  found, the function needs to print out "A match was found" and then the *
+ *  concatenated sequence. You can use the print_sequence_part function to  *
+ *  help with printing out the concatenated sequence. If a match was not    *
+ *  found, the function needs to print out "No match found".                *
+ *                                                                          *
+ *  There are two cases for matching that the function should check for.    *
+ *  First is if the target sequence appears inside the base sequence        *
+ *  itself.                                                                 *
+ *  For example:                                                            *
+ *                                                                          *
+ *  Base: AAACTGGGT             =>  A match was found.                      *
+ *  Target: ACTGG                   AAACTGGGT                               *
+ *                                                                          *
+ *  This would be a match because the target string ACTGG appears fully     *
+ *  within the base seqeunce.                                               *
+ *                                                                          *
+ *  The other case is if the base sequence is a proper prefix to the target *
+ *  string (the last bases of base sequence are the same as the first bases *
+ *  of the target sequence) AND the length of the overlap is equal to or    *
+ *  greater than the threshold. For example, assuming a threshold of 3:     *
+ *                                                                          *
+ *  Base: AAACTGGG              =>  A match was found.                      *
+ *  Target:    GGGTC                AAACTGGGTC                              *
+ *                                                                          *
+ *  Base: AAACTGGG              =>  No match found.                         *
+ *  Target:     GGACT                                                       *
+ *                                                                          *
+ *  The first example is a match because GGG is the last 3 bases of the     *
+ *  base and the first 3 bases of the target. The second example is NOT a   *
+ *  match because only 2 bases overlap.                                     *
+ *                                                                          *
+ *  One way to implement this is by lining up s2 at the end of s1 so that   *
+ *  they have `threshold` bases overlap. If no valid match is found, slide  *
+ *  s2 to left by one position. Repeat until either a match is found or no  *
+ *  overlap >= threshold is possible anymore.                               *
+ *                                                                          *
+ *  Example:                                                                * 
+ *  --------                                                                * 
+ *  s1 = CCGTTACAGG, s2 = TACAG, threshold = 3                              * 
+ *                                                                          * 
+ *  CCGTTACAGG                                                              * 
+ *         TACAG                                                            * 
+ *                                                                          * 
+ *  CCGTTACAGG                                                              * 
+ *        TACAG                                                             * 
+ *                                                                          * 
+ *  CCGTTACAGG                                                              * 
+ *       TACAG                                                              * 
+ *                                                                          * 
+ *  CCGTTACAGG                  =>  A match was found.                      *
+ *      TACAG                       CCGTTACAGG                              *
+ *                                                                          *
+ *                                                                          *
+ *  -----                                                                   *
+ *  BONUS                                                                   *
+ *  -----                                                                   *
+ *  For bonus points, add functionality to detect matches where the target  *
+ *  sequence is a proper prefix to the base sequence. For example:          *
+ *                                                                          *
+ *  Base:     AAACTGGG          =>  A match was found.                      *
+ *  Target: GTAAA                   GTAAACTGGG                              *
+ *                                                                          *
+ *  This would be a match because because AAA is the last 3 bases of the    *
+ *  target sequence and the first 3 bases of the base sequence.             *
+ *                                                                          *
+ ****************************************************************************/
+_Bool match(const char s1[], const char s2[],
+     int len1, int len2, int threshold) {
+   // FIXME:  This is where the real work has to happen 
+   //         implement this function using print_sequence_part as needed
+
+    printf("No match found.\n");
+    return 0;
+}
diff --git a/gitlog.txt b/gitlog.txt
new file mode 100644
index 0000000..e69de29
diff --git a/reference b/reference
new file mode 100755
index 0000000..1ff916b
Binary files /dev/null and b/reference differ
diff --git a/test.sh b/test.sh
new file mode 100755
index 0000000..cd2edd0
--- /dev/null
+++ b/test.sh
@@ -0,0 +1,252 @@
+#!/bin/bash
+#set -x
+
+REFERENCE=./reference
+PGM=./assignment-2
+
+# simple valid
+BASE_SEQ1="AAAAAAAAAAAAAAAAAAAA"
+TARGET_SEQ1="AAAAA"
+
+# VALID but has invalid characters that need to be ignored
+BASE_SEQ2="aAAAaAAAaAAAaAAAaAAaAAaAaAaAaAaaaa"
+TARGET_SEQ2="AAAAA"
+
+# BASE is invalid: too short
+BASE_SEQ3="A"
+TARGET_SEQ3="AAAAA"
+
+BASE_SEQ4="AAAAAAAAAAAAAAAAAAA"
+TARGET_SEQ4="AAAAA"
+
+# base has invalid character
+BASE_SEQ5="AAAAAAAAAAAAAAAAAAAB"
+TARGET_SEQ5="AAAAA"
+
+# match, full overlap
+BASE_SEQ6="GGGGGGGGAAAAAGGGGGGG"
+TARGET_SEQ6="AAAAA"
+
+BASE_SEQ7="AAAAAGGGGGGGGGGGGGGG"
+TARGET_SEQ7="AAAAA"
+
+BASE_SEQ8="GGGGGGGGGGGGGGGAAAAA"
+TARGET_SEQ8="AAAAA"
+
+# no match
+BASE_SEQ9="TTTTTTTTTTTTTTTTTTTT"
+TARGET_SEQ9="AAAAA"
+
+BASE_SEQ10="ACGTACGTACGTACGTACGT"
+TARGET_SEQ10="AAAAA"
+
+# target has invalid character, too short
+BASE_SEQ11="ACGTACGTACGTACGTACGT"
+TARGET_SEQ11="ACGTH"
+
+# match, either full overlap or target as suffix
+BASE_SEQ12="ACGTACGTACGTACGTACGT"
+TARGET_SEQ12="ACGTA"
+
+# match, target as suffix
+BASE_SEQ13="ACGTACGTACGTACGTACGT"
+TARGET_SEQ13="ACGTT"
+
+# match, target as suffix
+BASE_SEQ14="ACGTTGCAACGTTGCAACGT"
+TARGET_SEQ14="CGTAA"
+
+# no match
+BASE_SEQ15="ACGTTGCAACGTTGCAACGT"
+TARGET_SEQ15="GTCAA"
+
+# match, full overlap, extra characters ignored
+BASE_SEQ16="ACGTACGTACGTACGTACGG"
+TARGET_SEQ16="TACGGG"
+
+# target too short
+BASE_SEQ17="AAAAAAAAAAAAAAAAAAAA"
+TARGET_SEQ17="A"
+
+BASE_SEQ18="AAAAAAAAAAAAAAAAAAAA"
+TARGET_SEQ18="AAAAB"
+
+BASE_SEQ19="AAAAAAAAAAAAAAAAAAAA"
+TARGET_SEQ19="AaAaa"
+
+# empty base
+BASE_SEQ20=""
+TARGET_SEQ20="AAAAA"
+
+# empty target
+BASE_SEQ21="AAAAAAAAAAAAAAAAAAAA"
+TARGET_SEQ21=""
+
+## bonus
+
+# valid, target as prefix
+BASE_BONUS1="ACGTTGCAACGTTGCAACGT"
+TARGET_BONUS1="GGACG"
+
+# valid, target as prefix with ignored characters
+BASE_BONUS2="AAGTACGTACGTACGTACGT"
+TARGET_BONUS2="TAAAGT"
+
+# valid, target as prefix
+BASE_BONUS3="ACGTACGTACGTACGTACGT"
+TARGET_BONUS3="GACGT"
+
+# invalid, threshold larger than match
+BASE_BONUS4="ACGTTGCAACGTTGCATTGG"
+TARGET_BONUS4="TTTAC"
+
+# invalid, threshold larger than match after ignored characters
+BASE_BONUS5="ACGTTGCAACGTTGCATTGG"
+TARGET_BONUS5="TTTACG"
+
+function run_test()
+{
+   base=$1
+   target=$2
+   
+   echo "Testing with BASE Sequence: $base and TARGET: $target"
+   solution="$(echo -e "${base}\n${target}" | $REFERENCE)"
+   answer="$(echo -e "${base}\n${target}" | $PGM)"
+   if [[ "$answer" == "$solution" ]]; then
+      echo "PASS"
+      echo "$solution"
+      return 0
+   fi
+   echo "FAIL: your program poduced: '$answer' output should have been: '$solution'"
+   return 1
+}
+
+total=0
+correct=0
+
+if run_test $BASE_SEQ1 $TARGET_SEQ1; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ2 $TARGET_SEQ2; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ3 $TARGET_SEQ3; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ4 $TARGET_SEQ4; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ5 $TARGET_SEQ5; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ6 $TARGET_SEQ6; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ7 $TARGET_SEQ7; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ8 $TARGET_SEQ8; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ9 $TARGET_SEQ9; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ10 $TARGET_SEQ10; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ11 $TARGET_SE11; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ12 $TARGET_SEQ12; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ13 $TARGET_SEQ13; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ14 $TARGET_SEQ14; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ15 $TARGET_SEQ15; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ16 $TARGET_SEQ16; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ17 $TARGET_SEQ17; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ18 $TARGET_SEQ18; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ19 $TARGET_SEQ19; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ20 $TARGET_SEQ20; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_SEQ21 $TARGET_SEQ21; then
+  ((correct++))
+fi
+((total++))
+
+if run_test $BASE_BONUS1 $TARGET_BONUS1; then
+  ((correct++))
+fi
+
+if run_test $BASE_BONUS2 $TARGET_BONUS2; then
+  ((correct++))
+fi
+
+if run_test $BASE_BONUS3 $TARGET_BONUS3; then
+  ((correct++))
+fi
+
+if run_test $BASE_BONUS4 $TARGET_BONUS4; then
+  ((correct++))
+fi
+
+if run_test $BASE_BONUS5 $TARGET_BONUS5; then
+  ((correct++))
+fi
+
+echo "score: ${correct}/${total}"
